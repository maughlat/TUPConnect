<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TUPConnect • Set Your Password</title>
    <link rel="icon" href="../assets/TUPConnect_Logo.png" type="image/png" />
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../styles.css" />
    <link rel="stylesheet" href="../styles/admin.css" />
    <!-- Supabase Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  </head>
  <body>
    <div class="background-glow" aria-hidden="true"></div>
    
    <main class="login-main">
      <div class="login-container surface">
        <div class="login-header">
          <h1>Set Your Password</h1>
          <p>Create a secure password for your organization account</p>
        </div>

        <!-- Password Setup Form -->
        <form class="login-form" id="passwordSetupForm">
          <div class="form-group">
            <label for="newPassword">New Password *</label>
            <input
              type="password"
              id="newPassword"
              name="newPassword"
              placeholder="Enter your new password"
              required
              autocomplete="new-password"
              minlength="6"
            />
            <small style="color: #666; font-size: 0.875rem; margin-top: 0.5rem; display: block;">
              Password must be at least 6 characters long
            </small>
          </div>

          <div class="form-group">
            <label for="confirmPassword">Confirm Password *</label>
            <input
              type="password"
              id="confirmPassword"
              name="confirmPassword"
              placeholder="Confirm your new password"
              required
              autocomplete="new-password"
              minlength="6"
            />
          </div>

          <!-- Error/Success Message -->
          <div id="passwordMessage" style="display: none; margin-bottom: 1rem;"></div>

          <button type="submit" class="btn-primary" id="submitBtn">Set Password</button>
        </form>

        <div class="login-footer">
          <a href="login.html" class="back-link">← Back to Login</a>
        </div>
      </div>
    </main>

    <script>
      // Initialize Supabase client with proper configuration
      const supabaseUrl = 'https://rbmfimbdtiyuiflunuhx.supabase.co';
      const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJibWZpbWJkdGl5dWlmbHVudWh4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjUwMzA4MDQsImV4cCI6MjA4MDYwNjgwNH0.5LUfiV2PH78x5ExLROR9b0Z9j1O1ND75JJdGnEg2r4E';
      
      // Create Supabase client with auto-refresh and proper storage
      const supabase = window.supabase.createClient(supabaseUrl, supabaseAnonKey, {
        auth: {
          autoRefreshToken: true,
          persistSession: true,
          detectSessionInUrl: true, // Critical: This enables automatic hash detection
          storage: window.localStorage
        }
      });
      
      console.log('Supabase client initialized with hash detection enabled');

      // Display message helper function
      function displayMessage(message, isError = false) {
        const messageDiv = document.getElementById('passwordMessage');
        if (!messageDiv) return;

        messageDiv.innerHTML = message;
        messageDiv.style.display = 'block';
        messageDiv.style.padding = '0.875rem 1rem';
        messageDiv.style.borderRadius = '8px';
        messageDiv.style.fontSize = '0.875rem';

        if (isError) {
          messageDiv.style.background = 'rgba(239, 68, 68, 0.1)';
          messageDiv.style.border = '1px solid rgba(239, 68, 68, 0.3)';
          messageDiv.style.color = '#dc2626';
        } else {
          messageDiv.style.background = 'rgba(34, 197, 94, 0.1)';
          messageDiv.style.border = '1px solid rgba(34, 197, 94, 0.3)';
          messageDiv.style.color = '#16a34a';
        }
      }

      // Hide message helper function
      function hideMessage() {
        const messageDiv = document.getElementById('passwordMessage');
        if (messageDiv) {
          messageDiv.style.display = 'none';
          messageDiv.innerHTML = '';
        }
      }

      // Global variable to track if we have a valid session
      let hasValidSession = false;

      // Function to parse hash parameters from URL
      function parseHashParams(hash) {
        const params = {};
        if (!hash || hash.length <= 1) return params;
        
        const hashString = hash.substring(1); // Remove the #
        const pairs = hashString.split('&');
        
        pairs.forEach(pair => {
          const [key, value] = pair.split('=');
          if (key && value) {
            params[decodeURIComponent(key)] = decodeURIComponent(value);
          }
        });
        
        return params;
      }

      // Function to manually set session from hash or query tokens
      async function setSessionFromHash(tokenParams) {
        try {
          if (!tokenParams.access_token) {
            console.log('Missing access_token in params');
            return false;
          }

          // refresh_token might be optional in some cases
          if (!tokenParams.refresh_token) {
            console.log('Warning: No refresh_token found, trying with access_token only');
          }

          console.log('Attempting to set session manually from tokens...');
          console.log('Token source:', tokenParams.access_token ? 'Found' : 'Missing');
          
          // Try to set session directly using the tokens
          const sessionData = {
            access_token: tokenParams.access_token
          };
          
          if (tokenParams.refresh_token) {
            sessionData.refresh_token = tokenParams.refresh_token;
          }
          
          const { data, error } = await supabase.auth.setSession(sessionData);

          if (error) {
            console.error('Error setting session from tokens:', error);
            console.error('Error details:', error.message);
            return false;
          }

          if (data?.session) {
            console.log('✓ Session set successfully from tokens');
            hasValidSession = true;
            return true;
          }

          return false;
        } catch (error) {
          console.error('Exception setting session from tokens:', error);
          return false;
        }
      }

      // Function to parse query parameters (fallback if hash is missing)
      function parseQueryParams() {
        const params = {};
        const queryString = window.location.search.substring(1);
        if (!queryString) return params;
        
        const pairs = queryString.split('&');
        pairs.forEach(pair => {
          const [key, value] = pair.split('=');
          if (key && value) {
            params[decodeURIComponent(key)] = decodeURIComponent(value);
          }
        });
        return params;
      }

      // Wait for page to fully load and Supabase to initialize
      window.addEventListener('load', async () => {
        // Wait a bit longer to ensure Supabase client is fully initialized
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Verify session on page load and handle recovery token
        try {
          // Parse URL hash for recovery token (primary method)
          const urlHash = window.location.hash;
          const hashParams = parseHashParams(urlHash);
          
          // Also check query parameters (fallback - sometimes Supabase uses query params)
          const queryParams = parseQueryParams();
          
          // Combine both - prefer hash, fallback to query
          const tokenParams = {
            ...queryParams,
            ...hashParams // Hash takes precedence
          };
          
          const hasRecoveryToken = (tokenParams.access_token && tokenParams.type === 'recovery') ||
                                   (hashParams.access_token && hashParams.type === 'recovery') ||
                                   (queryParams.access_token && queryParams.type === 'recovery');
          
          console.log('=== SESSION INITIALIZATION DEBUG ===');
          console.log('Full URL:', window.location.href);
          console.log('URL Hash:', urlHash ? urlHash.substring(0, 100) + '...' : 'Missing');
          console.log('URL Search (Query):', window.location.search || 'Missing');
          console.log('Hash Params Keys:', Object.keys(hashParams));
          console.log('Query Params Keys:', Object.keys(queryParams));
          console.log('Combined Token Params:', Object.keys(tokenParams));
          console.log('Has Recovery Token:', hasRecoveryToken);
          console.log('Access Token Present:', !!(tokenParams.access_token || hashParams.access_token || queryParams.access_token));
          console.log('Refresh Token Present:', !!(tokenParams.refresh_token || hashParams.refresh_token || queryParams.refresh_token));
          
          // If no tokens at all, just log to console - don't show error to user
          // The password setup function will handle validation when form is submitted
          if (!hasRecoveryToken && !urlHash && !window.location.search) {
            console.warn('⚠️ No tokens detected in URL, but proceeding. Password setup will verify session on submit.');
            // Don't show error - let password setup function handle it
            // Don't return - allow form to be displayed
          }

          // METHOD 1: Check for existing session first
          let { data: { session }, error: sessionError } = await supabase.auth.getSession();
          
          console.log('Method 1 - Initial session check:', session ? 'Found' : 'Not found');
          if (sessionError) console.log('Session error:', sessionError);

          // If we already have a session, great!
          if (session && session.user) {
            hasValidSession = true;
            console.log('✓ Valid session already exists');
            console.log('User email:', session.user.email);
            console.log('User ID:', session.user.id);
            hideMessage();
            return;
          }

          // METHOD 2: If no session but we have recovery token, try manual session setting
          if (!session && hasRecoveryToken) {
            console.log('Method 2 - Recovery token detected. Attempting manual session setup...');
            
            // Try to set session manually from tokens (hash or query params)
            const sessionSet = await setSessionFromHash(tokenParams);
            
            if (sessionSet) {
              // Verify session was set
              const verifyResult = await supabase.auth.getSession();
              if (verifyResult.data?.session) {
                session = verifyResult.data.session;
                hasValidSession = true;
                console.log('✓ Session verified after manual setup');
                hideMessage();
            return;
          }
            }
          }

          // METHOD 3: Set up auth state change listener and wait
          if (!hasValidSession && hasRecoveryToken) {
            console.log('Method 3 - Setting up auth state listener and waiting...');
            
            let sessionFound = false;
            const authSubscription = supabase.auth.onAuthStateChange(async (event, newSession) => {
              console.log('Auth state changed:', event, newSession ? 'Has session' : 'No session');
              
              if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED' || event === 'PASSWORD_RECOVERY') {
                if (newSession && newSession.user) {
                  console.log('✓ Session established via auth state change');
                  hasValidSession = true;
                  session = newSession;
                  sessionFound = true;
                  hideMessage();
                  
                  // Clean up subscription
                  setTimeout(() => {
                    authSubscription.data?.subscription?.unsubscribe();
                  }, 1000);
                }
              }
            });

            // Wait for session to be established (with multiple getSession calls)
            for (let i = 0; i < 8; i++) {
              await new Promise(resolve => setTimeout(resolve, 400));
              
              const checkResult = await supabase.auth.getSession();
              if (checkResult.data?.session && checkResult.data.session.user) {
                session = checkResult.data.session;
                hasValidSession = true;
                sessionFound = true;
                console.log(`✓ Session found on attempt ${i + 1}`);
                hideMessage();
                break;
              }
            }

            // Clean up subscription after timeout
            setTimeout(() => {
              authSubscription.data?.subscription?.unsubscribe();
            }, 5000);
          }

          // METHOD 4: Final attempt - try setting session again after delay
          if (!hasValidSession && hasRecoveryToken) {
            console.log('Method 4 - Final attempt: Retrying session setup after delay...');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            const finalSessionSet = await setSessionFromHash(tokenParams);
            if (finalSessionSet) {
              const finalCheck = await supabase.auth.getSession();
              if (finalCheck.data?.session) {
                session = finalCheck.data.session;
                hasValidSession = true;
                console.log('✓ Session established in final attempt');
                hideMessage();
              }
            }
          }

          // Final verification
          if (!hasValidSession) {
            const lastCheck = await supabase.auth.getSession();
            if (lastCheck.data?.session && lastCheck.data.session.user) {
              session = lastCheck.data.session;
              hasValidSession = true;
              console.log('✓ Session found in final verification');
              hideMessage();
            }
          }

          console.log('=== FINAL SESSION CHECK ===');
          console.log('Has Valid Session:', hasValidSession);
          console.log('Session:', session ? 'Found' : 'Not found');
          if (session) {
            console.log('User email:', session.user.email);
            console.log('User ID:', session.user.id);
          }

          // Final check: Try one more time to get session before showing error
          if (!hasValidSession && !session) {
            // Last attempt - sometimes session needs a moment
            await new Promise(resolve => setTimeout(resolve, 500));
            const finalCheck = await supabase.auth.getSession();
            if (finalCheck.data?.session && finalCheck.data.session.user) {
              session = finalCheck.data.session;
              hasValidSession = true;
              console.log('✓ Session found in final check');
            }
          }

          // Only show error if we truly don't have a session AND password form submission would fail
          // Don't show error prematurely - let the form submission handle it
          if (hasValidSession || session) {
            console.log('✅ Session is valid. Password form is ready.');
            hideMessage();
          } else {
            // Only log to console, don't show error message to user yet
            // The password setup function will show appropriate error if session is actually needed
            console.warn('⚠️ Session not detected in URL, but proceeding anyway. If password setup fails, you may need a new activation link.');
            hideMessage(); // Hide any error messages, let form submission handle validation
          }

        } catch (error) {
          console.error('❌ Error in session initialization:', error);
          displayMessage(
            'An error occurred while verifying your activation link. Please try again or request a new activation email.',
            true
          );
        }
      });

      /**
       * Complete password setup function for Organization Account Activation
       * 
       * This function:
       * 1. Updates the user's password in Supabase Auth
       * 2. Finds the organization linked to this user (via email match)
       * 3. Updates the organization's account_status to 'Account Activated'
       * 4. Returns success/error status
       * 
       * @param {string} newPassword - The new password to set
       * @returns {Promise<Object>} - Returns { success: boolean, error: string|null }
       */
      async function handlePasswordSetup(newPassword) {
        try {
          console.log('=== PASSWORD SETUP START ===');
          console.log('Has Valid Session Flag:', hasValidSession);
          
          // Step 1: Try to update password first (Supabase might have session even if getSession() doesn't return it)
          // If password update succeeds, we know we have a valid session
          console.log('Attempting password update (Supabase may have session internally)...');
          
          let updateData = null;
          let updateError = null;
          let session = null;
          let userEmail = null;
          let userId = null;

          // Try password update first - this might work even if getSession() doesn't return session
          const passwordUpdateResult = await supabase.auth.updateUser({
            password: newPassword
          });

          updateData = passwordUpdateResult.data;
          updateError = passwordUpdateResult.error;

          // If password update succeeded, try to get session info
          if (!updateError && updateData?.user) {
            console.log('✓ Password update succeeded - session is valid');
            userEmail = updateData.user.email;
            userId = updateData.user.id;
            session = { user: updateData.user }; // Create session object from user data
            
            // Try to get full session
            const sessionCheck = await supabase.auth.getSession();
            if (sessionCheck.data?.session) {
              session = sessionCheck.data.session;
            }
          } else {
            // Password update failed - try to establish session first
            console.log('Password update failed, attempting to establish session...');
            
            // Method 1: Try getSession multiple times
            for (let attempt = 0; attempt < 15; attempt++) {
              const result = await supabase.auth.getSession();
              if (result.data?.session && result.data.session.user) {
                session = result.data.session;
                hasValidSession = true;
                userEmail = session.user.email;
                userId = session.user.id;
                console.log(`✓ Session found on attempt ${attempt + 1}`);
                break;
              }
              await new Promise(resolve => setTimeout(resolve, 200));
            }
            
            // Method 2: Try manual session from URL tokens
            if (!session) {
              const urlHash = window.location.hash;
              const hashParams = parseHashParams(urlHash);
              const queryParams = parseQueryParams();
              const tokenParams = { ...queryParams, ...hashParams };
              
              if (tokenParams.access_token) {
                console.log('Attempting manual session setup from URL tokens...');
                const sessionSet = await setSessionFromHash(tokenParams);
                if (sessionSet) {
                  const finalResult = await supabase.auth.getSession();
                  if (finalResult.data?.session) {
                    session = finalResult.data.session;
                    hasValidSession = true;
                    userEmail = session.user.email;
                    userId = session.user.id;
                    console.log('✓ Session established from URL tokens');
                  }
                }
              }
            }
            
            // If we now have a session, try password update again
            if (session && session.user) {
              console.log('Session established, retrying password update...');
              const retryUpdate = await supabase.auth.updateUser({
            password: newPassword
          });

              if (!retryUpdate.error && retryUpdate.data?.user) {
                updateData = retryUpdate.data;
                updateError = null;
                console.log('✓ Password update succeeded on retry');
              } else {
                updateError = retryUpdate.error;
                console.error('Password update still failed:', retryUpdate.error);
              }
            }
          }

          // Final check - if password update failed, return error
          if (updateError || !updateData) {
            console.error('❌ Password update failed after all attempts');
            console.error('Error:', updateError);
            console.error('Session available:', !!session);
            return {
              success: false,
              error: updateError?.message || 'Failed to set password. Please make sure you clicked the activation link directly from your email. If the problem persists, request a new activation email.'
            };
          }

          if (!session || !session.user) {
            // We have password update data, extract user info from it
            if (updateData?.user) {
              userEmail = updateData.user.email;
              userId = updateData.user.id;
              console.log('✓ Using user info from password update result');
            } else {
              console.error('❌ No session and no user data from password update');
              return {
                success: false,
                error: 'Unable to retrieve user information. Please try again or request a new activation email.'
              };
            }
          } else {
            userEmail = session.user.email;
            userId = session.user.id;
          }

          console.log('=== PASSWORD SETUP DEBUG ===');
          console.log('User ID:', userId);
          console.log('User Email:', userEmail);
          console.log('Session:', session ? 'Available' : 'Not available (but password update succeeded)');
          console.log('===========================');

          // Step 2: Password already updated above, continue with organization activation

          if (updateError) {
            console.error('Password update error:', updateError);
            return {
              success: false,
              error: updateError.message || 'Failed to set password. Please try again.'
            };
          }

          // Password update already handled above, this check should never fail
          // But keep it for safety
          if (!updateData || !updateData.user) {
            return {
              success: false,
              error: 'Password update failed. Please try again.'
            };
          }

          console.log('✓ Password updated successfully for user:', userId || updateData.user.id);

          // Step 3: Find the organization linked to this user via email
          // Organizations are linked to users by matching organizations.email with user.email
          const { data: organization, error: orgError } = await supabase
            .from('organizations')
            .select('id, name, email, account_status')
            .eq('email', userEmail)
            .maybeSingle(); // Use maybeSingle() to return null if no match instead of throwing

          if (orgError) {
            console.error('Error finding organization:', orgError);
            // Don't fail the whole operation - password was already updated
            // Just log a warning
            console.warn('Password updated but failed to update organization status:', orgError.message);
            return {
              success: true, // Password was successfully updated
              error: null,
              warning: 'Password set successfully, but could not update organization status. Please contact support.'
            };
          }

          if (!organization) {
            console.warn('No organization found for email:', userEmail);
            // Password was successfully updated, but no organization match
            // This shouldn't happen in normal flow, but we'll handle it gracefully
            return {
              success: true,
              error: null,
              warning: 'Password set successfully, but no matching organization found. Please contact support.'
            };
          }

          console.log('✓ Organization found:', organization.name, '(ID:', organization.id + ')');
          console.log('Current account_status:', organization.account_status);
          console.log('Current is_active:', organization.is_active);

          // Step 4: Activate organization using database function (bypasses RLS)
          // This function will:
          // 1. Update account_status to 'Account Activated'
          // 2. Set is_active to true
          // 3. Create user_roles record
          // All in one transaction, bypassing RLS
          console.log('Activating organization using database function...');
          console.log('Organization ID:', organization.id);
          console.log('Organization Email:', userEmail);
          console.log('Current status:', organization.account_status);
          console.log('Current is_active:', organization.is_active);
          
          // Use database function to activate organization (bypasses RLS)
          const { data: activationResult, error: activationError } = await supabase
            .rpc('activate_organization_by_email', {
              org_email: userEmail
            });

          if (activationError) {
            console.error('❌ Error calling activation function:', activationError);
            // Fallback to direct update (may fail due to RLS, but worth trying)
            console.log('Falling back to direct update...');
          }

          // If function succeeded, use its result
          let updatedOrg = null;
          let updateStatusError = null;
          
          if (activationResult && activationResult.success) {
            console.log('✓ Organization activated via database function');
            console.log('Activation result:', activationResult);
            
            // Fetch the updated organization to verify
            const { data: verifyOrg, error: verifyError } = await supabase
              .from('organizations')
              .select('id, name, email, account_status, is_active')
              .eq('id', organization.id)
              .single();
            
            if (!verifyError && verifyOrg) {
              updatedOrg = verifyOrg;
            }
          } else {
            // Function failed or doesn't exist, try direct update
            console.log('Attempting direct update (may fail due to RLS)...');
            const { data: directUpdate, error: directError } = await supabase
              .from('organizations')
              .update({ 
                account_status: 'Account Activated',
                is_active: true
              })
              .eq('id', organization.id)
              .select()
              .single();
            
            updatedOrg = directUpdate;
            updateStatusError = directError;
          }

          if (updateStatusError) {
            console.error('❌ Error updating organization status:', updateStatusError);
            console.error('Error code:', updateStatusError.code);
            console.error('Error message:', updateStatusError.message);
            console.error('Error details:', JSON.stringify(updateStatusError, null, 2));
            
            // If RLS is blocking, try to verify if update actually happened
            console.log('Update failed, checking if status changed anyway...');
            const { data: verifyOrg, error: verifyError } = await supabase
              .from('organizations')
              .select('id, name, email, account_status, is_active')
              .eq('id', organization.id)
              .single();
            
            if (!verifyError && verifyOrg) {
              console.log('Current organization status after failed update:', verifyOrg.account_status);
              console.log('Current is_active:', verifyOrg.is_active);
              
              if (verifyOrg.account_status === 'Account Activated' || verifyOrg.is_active === true) {
                console.log('✓ Organization status is already activated (update may have succeeded despite error)');
                // Continue with role creation
              } else {
                console.error('❌ Organization status update failed and status is not activated');
                return {
                  success: true, // Password was successfully updated
                  error: null,
                  warning: 'Password set successfully, but could not update organization status due to permissions. The SQL trigger should handle this automatically. Please try logging in - the database trigger will create your role.'
                };
              }
            }
          } else {
            console.log('✓ Organization status updated successfully');
            console.log('Updated status:', updatedOrg.account_status);
            console.log('Updated is_active:', updatedOrg.is_active);
          }

          // Verify the update actually worked
          const { data: finalVerify, error: finalVerifyError } = await supabase
            .from('organizations')
            .select('id, name, email, account_status, is_active')
            .eq('id', organization.id)
            .single();

          if (!finalVerifyError && finalVerify) {
            console.log('Final verification - Organization status:', finalVerify.account_status);
            console.log('Final verification - is_active:', finalVerify.is_active);
            
            if (finalVerify.account_status !== 'Account Activated' && finalVerify.is_active !== true) {
              console.warn('⚠️ Warning: Organization status update may have failed. Status is:', finalVerify.account_status);
              console.warn('This may be due to RLS policies. The database trigger should handle activation.');
            }
          }

          // Step 5: Create or update user_roles record to link user to organization
          console.log('Creating user_roles record...');
          console.log('User ID:', userId);
          console.log('Organization ID:', organization.id);
          
          // First, check if role already exists
          const { data: existingRole, error: checkError } = await supabase
            .from('user_roles')
            .select('*')
            .eq('user_id', userId)
            .maybeSingle();

          if (checkError && checkError.code !== 'PGRST116') { // PGRST116 = no rows returned, which is OK
            console.error('Error checking existing role:', checkError);
          }

          let userRoleData;
          let roleError;

          if (existingRole) {
            // Update existing record
            console.log('User role exists, updating...');
            const { data: updatedRole, error: updateRoleError } = await supabase
              .from('user_roles')
              .update({
                organization_id: organization.id,
                role: 'org_officer'
              })
              .eq('user_id', userId)
              .select()
              .single();
            
            userRoleData = updatedRole;
            roleError = updateRoleError;
          } else {
            // Insert new record
            console.log('Creating new user role...');
            const { data: newRole, error: insertRoleError } = await supabase
              .from('user_roles')
              .insert({
                user_id: userId,
                organization_id: organization.id,
                role: 'org_officer'
              })
              .select()
              .single();
            
            userRoleData = newRole;
            roleError = insertRoleError;
          }

          if (roleError) {
            console.error('❌ Error creating/updating user_roles record:', roleError);
            console.error('Error details:', JSON.stringify(roleError, null, 2));
            
            // Try one more time with a different approach (direct insert, ignoring conflicts)
            console.log('Retrying user role creation with direct insert...');
            const { data: retryRole, error: retryError } = await supabase
              .from('user_roles')
              .insert({
                user_id: userId,
                organization_id: organization.id,
                role: 'org_officer'
              }, {
                onConflict: 'user_id'
              })
              .select()
              .single();

            if (retryError) {
              console.error('❌ Retry also failed:', retryError);
              // Don't fail - password and org status are updated
              // The login function will try to create it automatically
              console.warn('⚠️ Password and organization updated, but failed to create user role. Login will attempt to create it automatically.');
              return {
                success: true,
                error: null,
                warning: 'Password set successfully and organization activated. User role will be created automatically on login.'
              };
            } else {
              userRoleData = retryRole;
              roleError = null;
              console.log('✓ User role created on retry');
            }
          }

          if (userRoleData) {
            console.log('✓ User role created/updated:', userRoleData.role);
            console.log('✓ User linked to organization:', organization.name);
            console.log('✓ Role record:', JSON.stringify(userRoleData, null, 2));
          }

          // Final verification of organization status
          let finalOrgStatus = null;
          if (finalVerify) {
            finalOrgStatus = finalVerify;
          } else if (updatedOrg) {
            finalOrgStatus = updatedOrg;
          }
          
          console.log('=== PASSWORD SETUP SUCCESS ===');
          if (finalOrgStatus) {
            console.log('Organization:', finalOrgStatus.name);
            console.log('Final Status:', finalOrgStatus.account_status);
            console.log('Final is_active:', finalOrgStatus.is_active);
          }
          if (userRoleData) {
            console.log('User Role:', userRoleData.role);
          }
          console.log('Organization ID:', organization.id);
          console.log('===============================');

          // Success: Password, organization status, and user role all updated
          return {
            success: true,
            error: null
          };

        } catch (error) {
          // Handle any unexpected errors
          console.error('handlePasswordSetup unexpected error:', error);
          return {
            success: false,
            error: error.message || 'An unexpected error occurred while setting your password'
          };
        }
      }

      // Form submission handler
      const passwordSetupForm = document.getElementById('passwordSetupForm');
      const submitBtn = document.getElementById('submitBtn');

      passwordSetupForm.addEventListener('submit', async function(e) {
        e.preventDefault();

        // Hide previous messages
        hideMessage();

        // Get form values
        const newPassword = document.getElementById('newPassword').value;
        const confirmPassword = document.getElementById('confirmPassword').value;

        // Validate passwords match
        if (newPassword !== confirmPassword) {
          displayMessage('Passwords do not match. Please try again.', true);
          return;
        }

        // Validate password length
        if (newPassword.length < 6) {
          displayMessage('Password must be at least 6 characters long.', true);
          return;
        }

        // Disable submit button during processing
        submitBtn.disabled = true;
        const originalButtonText = submitBtn.textContent;
        submitBtn.textContent = 'Setting Password...';

        // Call password setup function
        const result = await handlePasswordSetup(newPassword);

        if (result.success) {
          // Show success message (include warning if present)
          const successMessage = result.warning 
            ? `✓ Password set successfully! ${result.warning} Redirecting to login page...`
            : '✓ Password set successfully! Redirecting to login page...';
          
          displayMessage(successMessage, false);

          // Wait a moment, then redirect to login page
          setTimeout(() => {
            window.location.href = 'login.html';
          }, 2000);
        } else {
          // Show error message
          displayMessage(result.error || 'Failed to set password. Please try again.', true);
          
          // Re-enable submit button
          submitBtn.disabled = false;
          submitBtn.textContent = originalButtonText;
        }
      });

      // Real-time password confirmation validation
      const confirmPasswordInput = document.getElementById('confirmPassword');
      confirmPasswordInput.addEventListener('input', function() {
        const newPassword = document.getElementById('newPassword').value;
        const confirmPassword = this.value;

        if (confirmPassword && newPassword !== confirmPassword) {
          this.setCustomValidity('Passwords do not match');
        } else {
          this.setCustomValidity('');
        }
      });
    </script>
  </body>
</html>

