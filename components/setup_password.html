<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>TUPConnect • Set Your Password</title>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Space+Grotesk:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <link rel="stylesheet" href="../styles.css" />
    <link rel="stylesheet" href="../styles/admin.css" />
    <!-- Supabase Client -->
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
  </head>
  <body>
    <div class="background-glow" aria-hidden="true"></div>
    
    <main class="login-main">
      <div class="login-container surface">
        <div class="login-header">
          <h1>Set Your Password</h1>
          <p>Create a secure password for your organization account</p>
        </div>

        <!-- Password Setup Form -->
        <form class="login-form" id="passwordSetupForm">
          <div class="form-group">
            <label for="newPassword">New Password *</label>
            <input
              type="password"
              id="newPassword"
              name="newPassword"
              placeholder="Enter your new password"
              required
              autocomplete="new-password"
              minlength="6"
            />
            <small style="color: #666; font-size: 0.875rem; margin-top: 0.5rem; display: block;">
              Password must be at least 6 characters long
            </small>
          </div>

          <div class="form-group">
            <label for="confirmPassword">Confirm Password *</label>
            <input
              type="password"
              id="confirmPassword"
              name="confirmPassword"
              placeholder="Confirm your new password"
              required
              autocomplete="new-password"
              minlength="6"
            />
          </div>

          <!-- Error/Success Message -->
          <div id="passwordMessage" style="display: none; margin-bottom: 1rem;"></div>

          <button type="submit" class="btn-primary" id="submitBtn">Set Password</button>
        </form>

        <div class="login-footer">
          <a href="login.html" class="back-link">← Back to Login</a>
        </div>
      </div>
    </main>

    <script>
      // Initialize Supabase client with proper configuration
      const supabaseUrl = 'https://rbmfimbdtiyuiflunuhx.supabase.co';
      const supabaseAnonKey = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InJibWZpbWJkdGl5dWlmbHVudWh4Iiwicm9sZSI6ImFub24iLCJpYXQiOjE3NjUwMzA4MDQsImV4cCI6MjA4MDYwNjgwNH0.5LUfiV2PH78x5ExLROR9b0Z9j1O1ND75JJdGnEg2r4E';
      
      // Create Supabase client with auto-refresh and proper storage
      const supabase = window.supabase.createClient(supabaseUrl, supabaseAnonKey, {
        auth: {
          autoRefreshToken: true,
          persistSession: true,
          detectSessionInUrl: true, // Critical: This enables automatic hash detection
          storage: window.localStorage
        }
      });
      
      console.log('Supabase client initialized with hash detection enabled');

      // Display message helper function
      function displayMessage(message, isError = false) {
        const messageDiv = document.getElementById('passwordMessage');
        if (!messageDiv) return;

        messageDiv.innerHTML = message;
        messageDiv.style.display = 'block';
        messageDiv.style.padding = '0.875rem 1rem';
        messageDiv.style.borderRadius = '8px';
        messageDiv.style.fontSize = '0.875rem';

        if (isError) {
          messageDiv.style.background = 'rgba(239, 68, 68, 0.1)';
          messageDiv.style.border = '1px solid rgba(239, 68, 68, 0.3)';
          messageDiv.style.color = '#dc2626';
        } else {
          messageDiv.style.background = 'rgba(34, 197, 94, 0.1)';
          messageDiv.style.border = '1px solid rgba(34, 197, 94, 0.3)';
          messageDiv.style.color = '#16a34a';
        }
      }

      // Hide message helper function
      function hideMessage() {
        const messageDiv = document.getElementById('passwordMessage');
        if (messageDiv) {
          messageDiv.style.display = 'none';
          messageDiv.innerHTML = '';
        }
      }

      // Global variable to track if we have a valid session
      let hasValidSession = false;

      // Function to parse hash parameters from URL
      function parseHashParams(hash) {
        const params = {};
        if (!hash || hash.length <= 1) return params;
        
        const hashString = hash.substring(1); // Remove the #
        const pairs = hashString.split('&');
        
        pairs.forEach(pair => {
          const [key, value] = pair.split('=');
          if (key && value) {
            params[decodeURIComponent(key)] = decodeURIComponent(value);
          }
        });
        
        return params;
      }

      // Function to manually set session from hash or query tokens
      async function setSessionFromHash(tokenParams) {
        try {
          if (!tokenParams.access_token) {
            console.log('Missing access_token in params');
            return false;
          }

          // refresh_token might be optional in some cases
          if (!tokenParams.refresh_token) {
            console.log('Warning: No refresh_token found, trying with access_token only');
          }

          console.log('Attempting to set session manually from tokens...');
          console.log('Token source:', tokenParams.access_token ? 'Found' : 'Missing');
          
          // Try to set session directly using the tokens
          const sessionData = {
            access_token: tokenParams.access_token
          };
          
          if (tokenParams.refresh_token) {
            sessionData.refresh_token = tokenParams.refresh_token;
          }
          
          const { data, error } = await supabase.auth.setSession(sessionData);

          if (error) {
            console.error('Error setting session from tokens:', error);
            console.error('Error details:', error.message);
            return false;
          }

          if (data?.session) {
            console.log('✓ Session set successfully from tokens');
            hasValidSession = true;
            return true;
          }

          return false;
        } catch (error) {
          console.error('Exception setting session from tokens:', error);
          return false;
        }
      }

      // Function to parse query parameters (fallback if hash is missing)
      function parseQueryParams() {
        const params = {};
        const queryString = window.location.search.substring(1);
        if (!queryString) return params;
        
        const pairs = queryString.split('&');
        pairs.forEach(pair => {
          const [key, value] = pair.split('=');
          if (key && value) {
            params[decodeURIComponent(key)] = decodeURIComponent(value);
          }
        });
        return params;
      }

      // Wait for page to fully load and Supabase to initialize
      window.addEventListener('load', async () => {
        // Wait a bit longer to ensure Supabase client is fully initialized
        await new Promise(resolve => setTimeout(resolve, 300));
        
        // Verify session on page load and handle recovery token
        try {
          // Parse URL hash for recovery token (primary method)
          const urlHash = window.location.hash;
          const hashParams = parseHashParams(urlHash);
          
          // Also check query parameters (fallback - sometimes Supabase uses query params)
          const queryParams = parseQueryParams();
          
          // Combine both - prefer hash, fallback to query
          const tokenParams = {
            ...queryParams,
            ...hashParams // Hash takes precedence
          };
          
          const hasRecoveryToken = (tokenParams.access_token && tokenParams.type === 'recovery') ||
                                   (hashParams.access_token && hashParams.type === 'recovery') ||
                                   (queryParams.access_token && queryParams.type === 'recovery');
          
          console.log('=== SESSION INITIALIZATION DEBUG ===');
          console.log('Full URL:', window.location.href);
          console.log('URL Hash:', urlHash ? urlHash.substring(0, 100) + '...' : 'Missing');
          console.log('URL Search (Query):', window.location.search || 'Missing');
          console.log('Hash Params Keys:', Object.keys(hashParams));
          console.log('Query Params Keys:', Object.keys(queryParams));
          console.log('Combined Token Params:', Object.keys(tokenParams));
          console.log('Has Recovery Token:', hasRecoveryToken);
          console.log('Access Token Present:', !!(tokenParams.access_token || hashParams.access_token || queryParams.access_token));
          console.log('Refresh Token Present:', !!(tokenParams.refresh_token || hashParams.refresh_token || queryParams.refresh_token));
          
          // If no tokens at all, show helpful error immediately
          if (!hasRecoveryToken && !urlHash && !window.location.search) {
            console.error('❌ NO RECOVERY TOKENS FOUND - The email link is missing authentication tokens!');
            console.error('This usually means:');
            console.error('1. SendGrid click tracking is enabled (most likely) - DISABLE IT!');
            console.error('2. Supabase redirect URL is not configured correctly');
            console.error('3. The email link went through a tracking redirect that lost the hash');
            console.error('SOLUTION: Go to SendGrid Dashboard → Settings → Tracking → Turn OFF Click Tracking');
            displayMessage(
              '❌ The activation link is missing authentication tokens. This is likely because SendGrid click tracking is enabled and stripping the hash tokens. Please: 1) Go to SendGrid Dashboard → Settings → Tracking → Turn OFF Click Tracking, 2) Wait 5 minutes, 3) Request a new activation email. See FIX_SENDGRID_LINK_TRACKING.md for details.',
              true
            );
            return;
          }

          // METHOD 1: Check for existing session first
          let { data: { session }, error: sessionError } = await supabase.auth.getSession();
          
          console.log('Method 1 - Initial session check:', session ? 'Found' : 'Not found');
          if (sessionError) console.log('Session error:', sessionError);

          // If we already have a session, great!
          if (session && session.user) {
            hasValidSession = true;
            console.log('✓ Valid session already exists');
            console.log('User email:', session.user.email);
            console.log('User ID:', session.user.id);
            hideMessage();
            return;
          }

          // METHOD 2: If no session but we have recovery token, try manual session setting
          if (!session && hasRecoveryToken) {
            console.log('Method 2 - Recovery token detected. Attempting manual session setup...');
            
            // Try to set session manually from tokens (hash or query params)
            const sessionSet = await setSessionFromHash(tokenParams);
            
            if (sessionSet) {
              // Verify session was set
              const verifyResult = await supabase.auth.getSession();
              if (verifyResult.data?.session) {
                session = verifyResult.data.session;
                hasValidSession = true;
                console.log('✓ Session verified after manual setup');
                hideMessage();
                return;
              }
            }
          }

          // METHOD 3: Set up auth state change listener and wait
          if (!hasValidSession && hasRecoveryToken) {
            console.log('Method 3 - Setting up auth state listener and waiting...');
            
            let sessionFound = false;
            const authSubscription = supabase.auth.onAuthStateChange(async (event, newSession) => {
              console.log('Auth state changed:', event, newSession ? 'Has session' : 'No session');
              
              if (event === 'SIGNED_IN' || event === 'TOKEN_REFRESHED' || event === 'PASSWORD_RECOVERY') {
                if (newSession && newSession.user) {
                  console.log('✓ Session established via auth state change');
                  hasValidSession = true;
                  session = newSession;
                  sessionFound = true;
                  hideMessage();
                  
                  // Clean up subscription
                  setTimeout(() => {
                    authSubscription.data?.subscription?.unsubscribe();
                  }, 1000);
                }
              }
            });

            // Wait for session to be established (with multiple getSession calls)
            for (let i = 0; i < 8; i++) {
              await new Promise(resolve => setTimeout(resolve, 400));
              
              const checkResult = await supabase.auth.getSession();
              if (checkResult.data?.session && checkResult.data.session.user) {
                session = checkResult.data.session;
                hasValidSession = true;
                sessionFound = true;
                console.log(`✓ Session found on attempt ${i + 1}`);
                hideMessage();
                break;
              }
            }

            // Clean up subscription after timeout
            setTimeout(() => {
              authSubscription.data?.subscription?.unsubscribe();
            }, 5000);
          }

          // METHOD 4: Final attempt - try setting session again after delay
          if (!hasValidSession && hasRecoveryToken) {
            console.log('Method 4 - Final attempt: Retrying session setup after delay...');
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            const finalSessionSet = await setSessionFromHash(tokenParams);
            if (finalSessionSet) {
              const finalCheck = await supabase.auth.getSession();
              if (finalCheck.data?.session) {
                session = finalCheck.data.session;
                hasValidSession = true;
                console.log('✓ Session established in final attempt');
                hideMessage();
              }
            }
          }

          // Final verification
          if (!hasValidSession) {
            const lastCheck = await supabase.auth.getSession();
            if (lastCheck.data?.session && lastCheck.data.session.user) {
              session = lastCheck.data.session;
              hasValidSession = true;
              console.log('✓ Session found in final verification');
              hideMessage();
            }
          }

          console.log('=== FINAL SESSION CHECK ===');
          console.log('Has Valid Session:', hasValidSession);
          console.log('Session:', session ? 'Found' : 'Not found');
          if (session) {
            console.log('User email:', session.user.email);
            console.log('User ID:', session.user.id);
          }

          // Final check: Try one more time to get session before showing error
          if (!hasValidSession && !session) {
            // Last attempt - sometimes session needs a moment
            await new Promise(resolve => setTimeout(resolve, 500));
            const finalCheck = await supabase.auth.getSession();
            if (finalCheck.data?.session && finalCheck.data.session.user) {
              session = finalCheck.data.session;
              hasValidSession = true;
              console.log('✓ Session found in final check');
            }
          }

          // Show error ONLY if we truly don't have a session after ALL attempts
          if (!hasValidSession && !session) {
            if (!hasRecoveryToken) {
              console.error('❌ No recovery token found in URL (no hash or query params)');
              console.error('This means the email link from Supabase is missing the tokens.');
              console.error('SOLUTION: Check Supabase Dashboard → Authentication → URL Configuration');
              console.error('1. Site URL should be: https://tupconnect.vercel.app');
              console.error('2. Redirect URL should include: https://tupconnect.vercel.app/components/setup_password.html');
              displayMessage(
                '⚠️ Warning: No tokens detected in URL, but you may still be able to proceed. If password setup fails, please check Supabase redirect URL configuration and request a new activation email.',
                true
              );
            } else {
              console.error('❌ Recovery token found but session not established after all methods');
              console.error('This may indicate:');
              console.error('1. Token is expired or invalid');
              console.error('2. Token was already used');
              console.error('3. Supabase client configuration issue');
              displayMessage(
                '⚠️ Warning: Session setup encountered issues. You may still be able to set your password. If it fails, please request a new activation email.',
                true
              );
            }
          } else {
            console.log('✅ Session is valid. Password form is ready.');
            hideMessage();
          }

        } catch (error) {
          console.error('❌ Error in session initialization:', error);
          displayMessage(
            'An error occurred while verifying your activation link. Please try again or request a new activation email.',
            true
          );
        }
      });

      /**
       * Complete password setup function for Organization Account Activation
       * 
       * This function:
       * 1. Updates the user's password in Supabase Auth
       * 2. Finds the organization linked to this user (via email match)
       * 3. Updates the organization's account_status to 'Account Activated'
       * 4. Returns success/error status
       * 
       * @param {string} newPassword - The new password to set
       * @returns {Promise<Object>} - Returns { success: boolean, error: string|null }
       */
      async function handlePasswordSetup(newPassword) {
        try {
          console.log('=== PASSWORD SETUP START ===');
          console.log('Has Valid Session Flag:', hasValidSession);
          
          // Step 1: Get current session - try multiple methods
          let session = null;
          
          // Method 1: Check global flag and try getSession
          if (hasValidSession) {
            const checkResult = await supabase.auth.getSession();
            if (checkResult.data?.session) {
              session = checkResult.data.session;
            }
          }
          
          // Method 2: If no session, try multiple times with delays
          if (!session) {
            console.log('Session not found, attempting multiple retrieval attempts...');
            for (let attempt = 0; attempt < 10; attempt++) {
              const result = await supabase.auth.getSession();
              if (result.data?.session && result.data.session.user) {
                session = result.data.session;
                hasValidSession = true;
                console.log(`✓ Session found on attempt ${attempt + 1}`);
                break;
              }
              await new Promise(resolve => setTimeout(resolve, 300));
            }
          }
          
          // Method 3: Try to manually set session from hash/query if still no session
          if (!session) {
            const urlHash = window.location.hash;
            const hashParams = parseHashParams(urlHash);
            const queryParams = parseQueryParams();
            const tokenParams = { ...queryParams, ...hashParams };
            
            if (tokenParams.access_token) {
              console.log('Attempting final manual session setup...');
              const sessionSet = await setSessionFromHash(tokenParams);
              if (sessionSet) {
                const finalResult = await supabase.auth.getSession();
                if (finalResult.data?.session) {
                  session = finalResult.data.session;
                  hasValidSession = true;
                }
              }
            }
          }
          
          // Final check
          if (!session) {
            console.error('❌ No session found after all attempts');
            console.error('URL hash present:', !!window.location.hash);
            console.error('Has Valid Session Flag:', hasValidSession);
            return {
              success: false,
              error: 'Auth session missing! Please make sure you clicked the link directly from your activation email. If the problem persists, request a new activation email.'
            };
          }
          
          if (!session.user) {
            console.error('❌ Session exists but no user data');
            return {
              success: false,
              error: 'Session is invalid. Please request a new activation email.'
            };
          }
          
          console.log('✓ Session verified');
          console.log('User email:', session.user.email);
          console.log('User ID:', session.user.id);

          const userEmail = session.user.email;
          const userId = session.user.id;

          console.log('=== PASSWORD SETUP DEBUG ===');
          console.log('User ID:', userId);
          console.log('User Email:', userEmail);
          console.log('===========================');

          // Step 2: Update user password using Supabase Auth
          const { data: updateData, error: updateError } = await supabase.auth.updateUser({
            password: newPassword
          });

          if (updateError) {
            console.error('Password update error:', updateError);
            return {
              success: false,
              error: updateError.message || 'Failed to set password. Please try again.'
            };
          }

          if (!updateData || !updateData.user) {
            return {
              success: false,
              error: 'Password update failed. Please try again.'
            };
          }

          console.log('✓ Password updated successfully for user:', userId);

          // Step 3: Find the organization linked to this user via email
          // Organizations are linked to users by matching organizations.email with user.email
          const { data: organization, error: orgError } = await supabase
            .from('organizations')
            .select('id, name, email, account_status')
            .eq('email', userEmail)
            .maybeSingle(); // Use maybeSingle() to return null if no match instead of throwing

          if (orgError) {
            console.error('Error finding organization:', orgError);
            // Don't fail the whole operation - password was already updated
            // Just log a warning
            console.warn('Password updated but failed to update organization status:', orgError.message);
            return {
              success: true, // Password was successfully updated
              error: null,
              warning: 'Password set successfully, but could not update organization status. Please contact support.'
            };
          }

          if (!organization) {
            console.warn('No organization found for email:', userEmail);
            // Password was successfully updated, but no organization match
            // This shouldn't happen in normal flow, but we'll handle it gracefully
            return {
              success: true,
              error: null,
              warning: 'Password set successfully, but no matching organization found. Please contact support.'
            };
          }

          console.log('✓ Organization found:', organization.name, '(ID:', organization.id + ')');

          // Step 4: Update the organization's account_status to 'Account Activated' and set is_active to true
          const { data: updatedOrg, error: updateStatusError } = await supabase
            .from('organizations')
            .update({ 
              account_status: 'Account Activated',
              is_active: true  // Also activate the organization
            })
            .eq('id', organization.id)
            .select()
            .single();

          if (updateStatusError) {
            console.error('Error updating organization status:', updateStatusError);
            // Password was successfully updated, but status update failed
            // Log error but don't fail the whole operation
            console.warn('Password updated but failed to update organization status:', updateStatusError.message);
            return {
              success: true, // Password was successfully updated
              error: null,
              warning: 'Password set successfully, but could not update organization status. Please contact support.'
            };
          }

          console.log('✓ Organization status updated to "Account Activated"');
          console.log('✓ Organization is_active set to true');

          // Step 5: Create or update user_roles record to link user to organization
          console.log('Creating user_roles record...');
          console.log('User ID:', userId);
          console.log('Organization ID:', organization.id);
          
          // First, check if role already exists
          const { data: existingRole, error: checkError } = await supabase
            .from('user_roles')
            .select('*')
            .eq('user_id', userId)
            .maybeSingle();

          if (checkError && checkError.code !== 'PGRST116') { // PGRST116 = no rows returned, which is OK
            console.error('Error checking existing role:', checkError);
          }

          let userRoleData;
          let roleError;

          if (existingRole) {
            // Update existing record
            console.log('User role exists, updating...');
            const { data: updatedRole, error: updateRoleError } = await supabase
              .from('user_roles')
              .update({
                organization_id: organization.id,
                role: 'org_officer'
              })
              .eq('user_id', userId)
              .select()
              .single();
            
            userRoleData = updatedRole;
            roleError = updateRoleError;
          } else {
            // Insert new record
            console.log('Creating new user role...');
            const { data: newRole, error: insertRoleError } = await supabase
              .from('user_roles')
              .insert({
                user_id: userId,
                organization_id: organization.id,
                role: 'org_officer'
              })
              .select()
              .single();
            
            userRoleData = newRole;
            roleError = insertRoleError;
          }

          if (roleError) {
            console.error('❌ Error creating/updating user_roles record:', roleError);
            console.error('Error details:', JSON.stringify(roleError, null, 2));
            
            // Try one more time with a different approach (direct insert, ignoring conflicts)
            console.log('Retrying user role creation with direct insert...');
            const { data: retryRole, error: retryError } = await supabase
              .from('user_roles')
              .insert({
                user_id: userId,
                organization_id: organization.id,
                role: 'org_officer'
              }, {
                onConflict: 'user_id'
              })
              .select()
              .single();

            if (retryError) {
              console.error('❌ Retry also failed:', retryError);
              // Don't fail - password and org status are updated
              // The login function will try to create it automatically
              console.warn('⚠️ Password and organization updated, but failed to create user role. Login will attempt to create it automatically.');
              return {
                success: true,
                error: null,
                warning: 'Password set successfully and organization activated. User role will be created automatically on login.'
              };
            } else {
              userRoleData = retryRole;
              roleError = null;
              console.log('✓ User role created on retry');
            }
          }

          if (userRoleData) {
            console.log('✓ User role created/updated:', userRoleData.role);
            console.log('✓ User linked to organization:', organization.name);
            console.log('✓ Role record:', JSON.stringify(userRoleData, null, 2));
          }

          console.log('=== PASSWORD SETUP SUCCESS ===');
          console.log('Organization:', updatedOrg.name);
          console.log('New Status:', updatedOrg.account_status);
          console.log('Is Active:', updatedOrg.is_active);
          console.log('User Role:', userRoleData.role);
          console.log('Organization ID:', organization.id);
          console.log('===============================');

          // Success: Password, organization status, and user role all updated
          return {
            success: true,
            error: null
          };

        } catch (error) {
          // Handle any unexpected errors
          console.error('handlePasswordSetup unexpected error:', error);
          return {
            success: false,
            error: error.message || 'An unexpected error occurred while setting your password'
          };
        }
      }

      // Form submission handler
      const passwordSetupForm = document.getElementById('passwordSetupForm');
      const submitBtn = document.getElementById('submitBtn');

      passwordSetupForm.addEventListener('submit', async function(e) {
        e.preventDefault();

        // Hide previous messages
        hideMessage();

        // Get form values
        const newPassword = document.getElementById('newPassword').value;
        const confirmPassword = document.getElementById('confirmPassword').value;

        // Validate passwords match
        if (newPassword !== confirmPassword) {
          displayMessage('Passwords do not match. Please try again.', true);
          return;
        }

        // Validate password length
        if (newPassword.length < 6) {
          displayMessage('Password must be at least 6 characters long.', true);
          return;
        }

        // Disable submit button during processing
        submitBtn.disabled = true;
        const originalButtonText = submitBtn.textContent;
        submitBtn.textContent = 'Setting Password...';

        // Call password setup function
        const result = await handlePasswordSetup(newPassword);

        if (result.success) {
          // Show success message (include warning if present)
          const successMessage = result.warning 
            ? `✓ Password set successfully! ${result.warning} Redirecting to login page...`
            : '✓ Password set successfully! Redirecting to login page...';
          
          displayMessage(successMessage, false);

          // Wait a moment, then redirect to login page
          setTimeout(() => {
            window.location.href = 'login.html';
          }, 2000);
        } else {
          // Show error message
          displayMessage(result.error || 'Failed to set password. Please try again.', true);
          
          // Re-enable submit button
          submitBtn.disabled = false;
          submitBtn.textContent = originalButtonText;
        }
      });

      // Real-time password confirmation validation
      const confirmPasswordInput = document.getElementById('confirmPassword');
      confirmPasswordInput.addEventListener('input', function() {
        const newPassword = document.getElementById('newPassword').value;
        const confirmPassword = this.value;

        if (confirmPassword && newPassword !== confirmPassword) {
          this.setCustomValidity('Passwords do not match');
        } else {
          this.setCustomValidity('');
        }
      });
    </script>
  </body>
</html>

